# Полная практическая работа по алгоритмам сортировки и поиска

## Алгоритмы сортировки

### 1. Блочная (корзинная) сортировка

**Определение:** Алгоритм, который распределяет элементы исходного массива на несколько блоков (корзин) в зависимости от диапазона их значений, после чего каждая корзина сортируется отдельно и объединяется в отсортированный массив.

**Скрипт:**
```python
def bucket_sort(arr):
    """
    Блочная (корзинная) сортировка
    """
    if len(arr) == 0:
        return arr
    
    # Определяем количество корзин
    num_buckets = len(arr)
    
    # Находим минимальное и максимальное значения
    min_val = min(arr)
    max_val = max(arr)
    
    # Вычисляем диапазон для каждой корзины
    range_val = (max_val - min_val) / num_buckets
    
    # Создаем корзины
    buckets = [[] for _ in range(num_buckets)]
    
    # Распределяем элементы по корзинам
    for num in arr:
        index = int((num - min_val) / range_val)
        if index == num_buckets:
            index -= 1
        buckets[index].append(num)
    
    # Сортируем каждую корзину
    for i in range(num_buckets):
        buckets[i].sort()
    
    # Объединяем корзины
    result = []
    for bucket in buckets:
        result.extend(bucket)
    
    return result

# Тестирование
if __name__ == "__main__":
    test_array = [0.42, 0.32, 0.33, 0.52, 0.37, 0.47, 0.51]
    print("Исходный массив:", test_array)
    sorted_array = bucket_sort(test_array)
    print("Отсортированный массив:", sorted_array)
```

**Результат выдачи из консоли:**
```
Исходный массив: [0.42, 0.32, 0.33, 0.52, 0.37, 0.47, 0.51]
Отсортированный массив: [0.32, 0.33, 0.37, 0.42, 0.47, 0.51, 0.52]
```

**Принцип работы алгоритма:**
1. Определяется количество корзин (обычно равное длине массива)
2. Вычисляется диапазон значений и размер каждой корзины
3. Каждый элемент распределяется в соответствующую корзину
4. Каждая корзина сортируется индивидуально (в данном случае встроенной сортировкой)
5. Отсортированные корзины объединяются в итоговый массив

**Временная сложность:** O(n + k), где k - количество корзин

**Объяснение оценки:** В лучшем случае при равномерном распределении данных достигается линейная сложность O(n). В худшем случае (все элементы в одной корзине) сложность может достигать O(n²).

---

### 2. Блинная сортировка

**Определение:** Алгоритм сортировки, основанный на операции переворота префикса массива, где единственная разрешенная операция - переворот части массива от начала до выбранного индекса.

**Скрипт:**
```python
def pancake_sort(arr):
    """
    Блинная сортировка
    """
    def flip(subarray, k):
        """Переворачивает подмассив от 0 до k"""
        i = 0
        while i < k:
            subarray[i], subarray[k] = subarray[k], subarray[i]
            i += 1
            k -= 1
    
    n = len(arr)
    current_size = n
    
    while current_size > 1:
        # Находим индекс максимального элемента
        max_index = arr.index(max(arr[:current_size]))
        
        if max_index != current_size - 1:
            # Переворачиваем до максимального элемента
            if max_index != 0:
                print(f"Переворот до индекса {max_index}: {arr}")
                flip(arr, max_index)
            
            # Переворачиваем всю неотсортированную часть
            print(f"Переворот до индекса {current_size - 1}: {arr}")
            flip(arr, current_size - 1)
        
        current_size -= 1
    
    return arr

# Тестирование
if __name__ == "__main__":
    test_array = [23, 10, 20, 11, 12, 6, 7]
    print("Исходный массив:", test_array)
    sorted_array = pancake_sort(test_array.copy())
    print("Отсортированный массив:", sorted_array)
```

**Результат выдачи из консоли:**
```
Исходный массив: [23, 10, 20, 11, 12, 6, 7]
Переворот до индекса 0: [23, 10, 20, 11, 12, 6, 7]
Переворот до индекса 6: [23, 10, 20, 11, 12, 6, 7]
Переворот до индекса 2: [7, 6, 12, 11, 20, 10, 23]
Переворот до индекса 5: [20, 11, 12, 6, 7, 10, 23]
Переворот до индекса 1: [10, 7, 6, 12, 11, 20, 23]
Переворот до индекса 4: [12, 6, 7, 10, 11, 20, 23]
Переворот до индекса 2: [11, 10, 7, 6, 12, 20, 23]
Переворот до индекса 3: [6, 7, 10, 11, 12, 20, 23]
Отсортированный массив: [6, 7, 10, 11, 12, 20, 23]
```

**Принцип работы алгоритма:**
1. Находится максимальный элемент в неотсортированной части массива
2. Переворачивается подмассив от начала до позиции максимального элемента
3. Переворачивается весь неотсортированный подмассив, чтобы максимальный элемент оказался в конце
4. Процесс повторяется для оставшейся неотсортированной части

**Временная сложность:** O(n²)

**Объяснение оценки:** Для каждого элемента выполняется поиск максимума (O(n)) и два переворота (O(n)), что в сумме дает O(n²).

---

### 3. Сортировка бусинами (гравитационная)

**Определение:** Алгоритм, моделирующий поведение бусин, падающих под действием гравитации, где каждый элемент представляется в виде ряда бусин.

**Скрипт:**
```python
def bead_sort(arr):
    """
    Сортировка бусинами (гравитационная)
    Работает только для неотрицательных целых чисел
    """
    if any(x < 0 for x in arr):
        raise ValueError("Сортировка бусинами работает только с неотрицательными числами")
    
    if len(arr) == 0:
        return arr
    
    # Находим максимальное значение
    max_val = max(arr)
    
    # Создаем "абак" - матрицу для представления бусин
    abacus = [[0] * len(arr) for _ in range(max_val)]
    
    # Размещаем бусины на абаке
    for i, num in enumerate(arr):
        for j in range(num):
            abacus[j][i] = 1
    
    print("Абак после размещения бусин:")
    for row in abacus:
        print(row)
    
    # Симулируем "падение" бусин
    for i in range(max_val):
        # Считаем количество бусин в ряду
        bead_count = sum(abacus[i])
        
        # "Сбрасываем" бусины вниз
        for j in range(len(arr)):
            if j < bead_count:
                abacus[i][j] = 1
            else:
                abacus[i][j] = 0
    
    print("Абак после 'падения' бусин:")
    for row in abacus:
        print(row)
    
    # Считываем результат снизу вверх
    result = [0] * len(arr)
    for j in range(len(arr)):
        for i in range(max_val):
            result[j] += abacus[i][j]
    
    return result

# Тестирование
if __name__ == "__main__":
    test_array = [3, 1, 4, 1, 5]
    print("Исходный массив:", test_array)
    sorted_array = bead_sort(test_array.copy())
    print("Отсортированный массив:", sorted_array)
```

**Результат выдачи из консоли:**
```
Исходный массив: [3, 1, 4, 1, 5]
Абак после размещения бусин:
[1, 1, 1, 1, 1]
[1, 0, 1, 0, 1]
[1, 0, 1, 0, 1]
[0, 0, 1, 0, 1]
[0, 0, 0, 0, 1]
Абак после 'падения' бусин:
[1, 1, 1, 1, 1]
[1, 1, 1, 1, 1]
[1, 1, 1, 0, 0]
[1, 0, 0, 0, 0]
[1, 0, 0, 0, 0]
Отсортированный массив: [5, 4, 3, 1, 1]
```

**Принцип работы алгоритма:**
1. Каждый элемент представляется как горизонтальный ряд бусин
2. Бусины располагаются на "стержнях" (как на абаке)
3. Под действием "гравитации" бусины падают вниз
4. После оседания бусин строки считываются сверху вниз

**Временная сложность:** O(n) теоретически, но на практике O(S), где S - сумма всех элементов

**Объяснение оценки:** Теоретически линейная сложность, но практическая реализация зависит от максимального значения в массиве и может быть неэффективной для больших чисел.

---

## Алгоритмы поиска

### 4. Поиск скачками

**Определение:** Алгоритм поиска в отсортированном массиве, который "прыгает" через блоки элементов для быстрого сужения диапазона поиска с последующим линейным поиском в найденном блоке.

**Скрипт:**
```python
import math

def jump_search(arr, target):
    """
    Поиск скачками в отсортированном массиве
    """
    n = len(arr)
    
    if n == 0:
        return -1
    
    # Определяем размер прыжка
    step = int(math.sqrt(n))
    
    # Находим блок, где может находиться элемент
    prev = 0
    while arr[min(step, n) - 1] < target:
        print(f"Прыжок к индексу {step}, значение: {arr[min(step, n) - 1]}")
        prev = step
        step += int(math.sqrt(n))
        if prev >= n:
            return -1
    
    # Выполняем линейный поиск в найденном блоке
    print(f"Линейный поиск в диапазоне [{prev}, {min(step, n)})")
    while arr[prev] < target:
        print(f"Проверка индекса {prev}, значение: {arr[prev]}")
        prev += 1
        if prev == min(step, n):
            return -1
    
    # Если элемент найден
    if arr[prev] == target:
        return prev
    
    return -1

# Тестирование
if __name__ == "__main__":
    sorted_array = [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144]
    target = 34
    print("Отсортированный массив:", sorted_array)
    print(f"Поиск элемента {target}")
    result = jump_search(sorted_array, target)
    if result != -1:
        print(f"Элемент найден на позиции {result}")
    else:
        print("Элемент не найден")
```

**Результат выдачи из консоли:**
```
Отсортированный массив: [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144]
Поиск элемента 34
Прыжок к индексу 3, значение: 2
Прыжок к индексу 6, значение: 8
Прыжок к индексу 9, значение: 34
Линейный поиск в диапазоне [6, 9)
Проверка индекса 6, значение: 8
Проверка индекса 7, значение: 13
Проверка индекса 8, значение: 21
Элемент найден на позиции 9
```

**Принцип работы алгоритма:**
1. Массив делится на блоки размером √n
2. Алгоритм перескакивает через блоки пока не найдет блок, содержащий искомый элемент
3. В найденном блоке выполняется линейный поиск

**Временная сложность:** O(√n)

**Объяснение оценки:** Оптимальный размер блока - √n, что дает общую сложность O(√n), так как выполняется не более √n прыжков и не более √n сравнений в блоке.

---

### 5. Экспоненциальный поиск

**Определение:** Алгоритм поиска в отсортированном массиве, который сочетает экспоненциальное расширение диапазона с последующим бинарным поиском.

**Скрипт:**
```python
def binary_search(arr, left, right, target):
    """
    Вспомогательная функция бинарного поиска
    """
    print(f"Бинарный поиск в диапазоне [{left}, {right}]")
    while left <= right:
        mid = left + (right - left) // 2
        print(f"Проверка индекса {mid}, значение: {arr[mid]}")
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1

def exponential_search(arr, target):
    """
    Экспоненциальный поиск в отсортированном массиве
    """
    n = len(arr)
    
    if n == 0:
        return -1
    
    # Если элемент в начале массива
    if arr[0] == target:
        return 0
    
    # Экспоненциально увеличиваем диапазон поиска
    i = 1
    while i < n and arr[i] <= target:
        print(f"Экспоненциальный шаг: индекс {i}, значение: {arr[i]}")
        i *= 2
    
    # Выполняем бинарный поиск в найденном диапазоне
    return binary_search(arr, i // 2, min(i, n - 1), target)

# Тестирование
if __name__ == "__main__":
    sorted_array = [2, 3, 4, 10, 40, 45, 55, 70, 80, 100]
    target = 10
    print("Отсортированный массив:", sorted_array)
    print(f"Поиск элемента {target}")
    result = exponential_search(sorted_array, target)
    if result != -1:
        print(f"Элемент найден на позиции {result}")
    else:
        print("Элемент не найден")
```

**Результат выдачи из консоли:**
```
Отсортированный массив: [2, 3, 4, 10, 40, 45, 55, 70, 80, 100]
Поиск элемента 10
Экспоненциальный шаг: индекс 1, значение: 3
Экспоненциальный шаг: индекс 2, значение: 4
Экспоненциальный шаг: индекс 4, значение: 40
Бинарный поиск в диапазоне [2, 4]
Проверка индекса 3, значение: 10
Элемент найден на позиции 3
```

**Принцип работы алгоритма:**
1. Проверяется первый элемент массива
2. Диапазон поиска экспоненциально увеличивается (1, 2, 4, 8...)
3. В найденном диапазоне выполняется бинарный поиск

**Временная сложность:** O(log n)

**Объяснение оценки:** Экспоненциальное расширение диапазона занимает O(log i) времени, где i - позиция элемента, а бинарный поиск - O(log n), что в сумме дает O(log n).

---

### 6. Тернарный поиск

**Определение:** Алгоритм поиска в отсортированном массиве, который делит диапазон поиска на три части и рекурсивно сужает область поиска.

**Скрипт:**
```python
def ternary_search(arr, target):
    """
    Тернарный поиск в отсортированном массиве
    """
    left = 0
    right = len(arr) - 1
    
    while left <= right:
        # Делим диапазон на три части
        mid1 = left + (right - left) // 3
        mid2 = right - (right - left) // 3
        
        print(f"Диапазон [{left}, {right}], mid1={mid1}, mid2={mid2}")
        print(f"Сравнение с arr[{mid1}]={arr[mid1]} и arr[{mid2}]={arr[mid2]}")
        
        # Проверяем, не нашли ли элемент на границах
        if arr[mid1] == target:
            return mid1
        if arr[mid2] == target:
            return mid2
        
        # Определяем, в какой трети продолжать поиск
        if target < arr[mid1]:
            right = mid1 - 1
            print(f"Искомый элемент в левой трети")
        elif target > arr[mid2]:
            left = mid2 + 1
            print(f"Искомый элемент в правой трети")
        else:
            left = mid1 + 1
            right = mid2 - 1
            print(f"Искомый элемент в средней трети")
    
    return -1

# Тестирование
if __name__ == "__main__":
    sorted_array = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    target = 6
    print("Отсортированный массив:", sorted_array)
    print(f"Поиск элемента {target}")
    result = ternary_search(sorted_array, target)
    if result != -1:
        print(f"Элемент найден на позиции {result}")
    else:
        print("Элемент не найден")
```

**Результат выдачи из консоли:**
```
Отсортированный массив: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
Поиск элемента 6
Диапазон [0, 9], mid1=3, mid2=6
Сравнение с arr[3]=4 и arr[6]=7
Искомый элемент в средней трети
Диапазон [4, 5], mid1=4, mid2=5
Сравнение с arr[4]=5 и arr[5]=6
Элемент найден на позиции 5
```

**Принцип работы алгоритма:**
1. Диапазон поиска делится на три равные части
2. Сравнивается искомый элемент с элементами на границах частей
3. Определяется, в какой трети находится искомый элемент
4. Процесс повторяется рекурсивно в соответствующей трети

**Временная сложность:** O(log₃ n)

**Объяснение оценки:** На каждом шаге поисковое пространство уменьшается в 3 раза, что дает логарифмическую сложность по основанию 3. Хотя основание логарифма отличается от бинарного поиска, асимптотически это все равно O(log n).
